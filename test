#!/usr/bin/env python3
import rclpy
from rclpy.node import Node
import importlib

# ========== USER CONFIG ==========
mode = None           # Leave None to auto-detect from datatype
datatype = "Float64"  # Just the type name, e.g., "String", "Int32", "Image"
node_name = "num_publisher"
topic_name = "number"
value = 42.5          # Can be number, string, or image frame
queue = 10
delay = 1.0           # seconds
# video_source = 0    # Only needed for video mode
# =================================

# Map common message types to their packages
TYPE_MAP = {
    "String": "std_msgs.msg",
    "Int32": "std_msgs.msg",
    "Float32": "std_msgs.msg",
    "Float64": "std_msgs.msg",
    "Bool": "std_msgs.msg",
    "Image": "sensor_msgs.msg",
}

# Guess mode if not given
def guess_mode_from_type(dtype):
    if dtype.lower() in ["image"]:
        return "image"
    elif dtype.lower() in ["string"]:
        return "string"
    elif dtype.lower().startswith("float") or dtype.lower().startswith("int") or dtype.lower() == "bool":
        return "number"
    return "string"  # default fallback

class GenericPublisher(Node):
    def __init__(self):
        super().__init__(node_name)

        # Auto-assign mode if None
        global mode
        if mode is None:
            mode = guess_mode_from_type(datatype)
            self.get_logger().info(f"Auto-detected mode: {mode}")

        # Auto-detect message module
        if "." in datatype:
            module_name, class_name = datatype.rsplit('.', 1)
        else:
            class_name = datatype
            module_name = TYPE_MAP.get(class_name)
            if not module_name:
                self.get_logger().error(
                    f"Unknown datatype '{datatype}'. Please specify full path like 'pkg.msg.TypeName'"
                )
                rclpy.shutdown()
                return

        msg_module = importlib.import_module(module_name)
        self.msg_class = getattr(msg_module, class_name)

        self.publisher_ = self.create_publisher(self.msg_class, topic_name, queue)
        self.timer = self.create_timer(delay, self.timer_callback)

        self.cap = None
        self.bridge = None
        if mode in ["image", "video"]:
            from cv_bridge import CvBridge
            import cv2
            self.cv2 = cv2
            self.bridge = CvBridge()
            if mode == "video":
                try:
                    from __main__ import video_source
                except ImportError:
                    self.get_logger().error("You must define 'video_source' in config for video mode")
                    rclpy.shutdown()
                    return
                self.cap = cv2.VideoCapture(video_source)

        self.get_logger().info(f"Publishing on '{topic_name}' with type '{module_name}.{class_name}'")

    def timer_callback(self):
        msg = None

        if mode in ["number", "float", "string"]:
            msg = self.msg_class()
            if hasattr(msg, 'data'):
                msg.data = value
            else:
                self.get_logger().error(f"Message type {datatype} has no 'data' field.")
                return

        elif mode == "image":
            if value is None:
                self.get_logger().error("No image frame provided in 'value'")
                return
            msg = self.bridge.cv2_to_imgmsg(value, encoding="bgr8")

        elif mode == "video":
            if not self.cap:
                self.get_logger().error("Video capture not initialized")
                return
            ret, frame = self.cap.read()
            if not ret:
                self.get_logger().info("End of video or camera error")
                rclpy.shutdown()
                return
            msg = self.bridge.cv2_to_imgmsg(frame, encoding="bgr8")

        if msg:
            self.publisher_.publish(msg)
            self.get_logger().info(f"Published message on {topic_name}")

def main(args=None):
    rclpy.init(args=args)
    node = GenericPublisher()
    try:
        rclpy.spin(node)
    except KeyboardInterrupt:
        pass
    finally:
        if node.cap:
            node.cap.release()
        node.destroy_node()
        rclpy.shutdown()

if __name__ == "__main__":
    main()
